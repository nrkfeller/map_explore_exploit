using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MathNet.Numerics.Random;

namespace ME2_Test
{
    static class MapFunctions
    {
        private static MersenneTwister _rng = new MersenneTwister(true);
        public static IEnumerable<Individual> MapNeighbors(Space SearchSpace, Func<Space, Individual> RandomSolution)
        {
            double number = 1.0;
            for(int i = 0; i < SearchSpace.Size; i++)
            {
                if(SearchSpace[i] is RealAxis)
                {
                    number *= ((RealAxis)SearchSpace[i]).Range;
                }
                else if(SearchSpace[i] is DiscreteAxis)
                {
                    number *= ((DiscreteAxis)SearchSpace[i]).Range;
                }
                else
                {
                    number *= ((BinaryAxis)SearchSpace[i]).Range;
                }
            }
            number = Math.Sqrt(number);
            for(int i = 0; i < number; i++)
            {
                var neighbor = RandomSolution(SearchSpace);
                yield return neighbor;
            }
        }
    }

    /// <summary>
    /// This class creates a set of random candidate solutions to begin optimization
    /// </summary>
    /// <typeparam name="S">The type of space to search</typeparam>
    /// <typeparam name="T">The type of candidate solution</typeparam>
    /// <typeparam name="C">The return type of the fitness function</typeparam>
    public class Map<S, T, C>
    {
        /// <summary>
        /// Random candidate solution generator
        /// </summary>
        public Func<S, T> RandomSolution { get; set; }
        /// <summary>
        /// Random set generator
        /// </summary>
        public Func<S, Func<S, T>, IEnumerable<T>> Neighbors { get; set; }
        /// <summary>
        /// Fitness function
        /// </summary>
        public Func<T, bool, C> Fitness { get; set; }
        /// <summary>
        /// Selection function
        /// </summary>
        public Func<IEnumerable<T>, int, IEnumerable<T>> Select { get; set; }
        /// <summary>
        /// The set of candidate solutions that results from mapping the space
        /// </summary>
        public IEnumerable<T> MappedSpace { get; set; }

        /// <summary>
        /// Create a Map of the space being searched
        /// </summary>
        /// <param name="space">The space to search</param>
        /// <param name="maximize">Type of optimization: maximize (true) or minimize (false)</param>
        /// <param name="survivorProportion">The proportion of Map candidate solutions to keep - 0.0 to 1.0</param>
        /// <param name="randomSolution">A function that generates a random solution given a space and returns the candidate solution</param>
        /// <param name="neighbors">A function that generates a number of random solutions given a space and returns the group of solutions</param>
        /// <param name="fitness">A function that returns a fitness value given a candidate solution and the type of optimization</param>
        /// <param name="fitnessApply">An action to apply a fitness value to a candidate solution</param>
        /// <param name="select">A function that selects from a group of random solutions and returns the selected group</param>
        public Map (S space, bool maximize, double survivorProportion, Func<S, T> randomSolution, Func<S, Func<S, T>, IEnumerable<T>> neighbors, 
                    Func<T, bool, C> fitness, Action<T, C> fitnessApply, Func<IEnumerable<T>, int, IEnumerable<T>> select)
        {
            if(Math.Abs(survivorProportion - 0.0) < Constants.TOLERANCE || Math.Abs(survivorProportion - 1.0) < Constants.TOLERANCE)
            {
                throw new ArgumentException("Map: Survivor Proportion must be between 0.0 and 1.0, inclusive");
            }

            this.RandomSolution = randomSolution;
            this.Neighbors = neighbors;
            this.Fitness = fitness;
            this.Select = select;

            T[] randomSet = this.Neighbors(space, this.RandomSolution).ToArray();
            for(int i = 0; i < randomSet.Count(); i++)
            {
                C fitnessScore = this.Fitness(randomSet.ElementAt(i), maximize);
                fitnessApply(randomSet.ElementAt(i), fitnessScore);
            }

            int survivors = (int)(survivorProportion * randomSet.Count());
            this.MappedSpace = this.Select(randomSet, survivors);
        }
    }
}
