using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MathNet.Numerics.Random;
using MathNet.Numerics.Distributions;

namespace ME2_Test
{
    static class ExploreFunctions
    {
        private static MersenneTwister _rng = new MersenneTwister(true);
        public static double ExploreP(Individual parent, Individual child, double totalFitness)
        {
            double normalizedParentFitness = parent.Fitness / totalFitness;
            double normalizedChildFitness = child.Fitness / totalFitness;
            return (-0.5 * (normalizedParentFitness - normalizedChildFitness)) + 0.5;
        }
        public static double ExploreTP(Space searchSpace, Individual parent, Individual child, double totalFitness)
        {
            double transitionProbability = ExploitFunctions.ExploitP(parent, child, totalFitness);
            double ncbd = ME2Functions.NormalizedCityBlockDistance(searchSpace, parent, child);
            if (Math.Abs(ncbd - 0.0D) < Constants.TOLERANCE)
            {
                transitionProbability = 0.0D;
            }
            else if (Math.Abs(ncbd - (Constants.CITYBLOCKSCALINGSTART * parent.Size)) <= Constants.TOLERANCE)
            {
                transitionProbability = (transitionProbability * ncbd) / (Constants.CITYBLOCKSCALINGSTART * parent.Size);
            }

            transitionProbability -= ExploreFunctions._rng.NextDouble(); // Uniform random noise between 0 and 1
            return transitionProbability;
        }
        public static void ApplyExplorePOM(Space S, Individual IndividualToAdjust)
        {
            double POM = 1.0;
            if(S.Size == 1)
            {
                POM = 1.0;
            }
            else if(S.Size == 2)
            {
                POM = 0.5;
            }
            else
            {
                POM = ContinuousUniform.Sample(ExploreFunctions._rng, 1.0 / S.Size, (1.0 - (1.0 / S.Size)) / 2);
            }
            IndividualToAdjust.MutationProbability = POM;
        }
    }
    class Explore<S, T, C>
    {
        public Func<S, bool, T, Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T>, Func<T, bool, C>, Action<T, C>, int, IEnumerable<T>> Neighbors { get; set; }
        public Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T> Mutate { get; set; }
        public Func<T, bool, C> Fitness { get; set; }
        public Func<IEnumerable<T>, C> TotalFitness { get; set; }
        public Action<T, C> ApplyFitness { get; set; }
        public Func<S, T, T, C, C> TransitionProbability { get; set; }
        public IEnumerable<T> Optimized { get; set; }
        private List<T> tabuList = new List<T>();

        public Explore(S space, bool maximize, IEnumerable<T> parents, Func<S, bool, T, Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T>, Func<T, bool, C>, Action<T, C>, int, IEnumerable<T>> neighbors, 
                       Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T> mutate, Func<T, bool, C> fitness, Action<T, C> applyFitness, Action<S, T> applyPOM, Func<S, T, T, C, C> transitionProbability,
                       Func<IEnumerable<T>, C> totalFitness, int generations)
        {
            this.Mutate = mutate;
            this.Neighbors = neighbors;
            this.Fitness = fitness;
            this.TotalFitness = totalFitness;
            this.ApplyFitness = applyFitness;
            this.TransitionProbability = transitionProbability;
            ConcurrentBag<T> oldSet = new ConcurrentBag<T>(parents);
            for(int i = 0; i < oldSet.Count(); i++)
            {
                applyPOM(space, oldSet.ElementAt(i));
            }
            ConcurrentBag<T> newSet = new ConcurrentBag<T>();
            Parallel.For(0, oldSet.Count(), current =>
                {
                    newSet.Add(this.Optimize(space, maximize, oldSet.Count(), oldSet.ElementAt(current), generations));
                }
            );
            Optimized = newSet;
        }

        private T Optimize(S space, bool maximize, int neighbors, T parent, int generations)
        {
            int currentGeneration = 0;
            List<C> transitionalProbabilities = new List<C>();
            T current = parent;

            do
            {
                IEnumerable<T> newNeighbors = this.Neighbors(space, maximize, current, this.Mutate, this.Fitness, this.ApplyFitness, neighbors);
                C newTotalFitness = this.TotalFitness(newNeighbors);
                foreach(T neighbor in newNeighbors)
                {
                    transitionalProbabilities.Add(this.TransitionProbability(space, current, neighbor, newTotalFitness));
                }

                int bestIndex = transitionalProbabilities.IndexOf(transitionalProbabilities.Max());
                if(newNeighbors.ElementAt(bestIndex) != null && !tabuList.Contains(newNeighbors.ElementAt(bestIndex)))
                {
                    tabuList.Add(current);
                    current = newNeighbors.ElementAt(bestIndex);
                }

                transitionalProbabilities.Clear();
                currentGeneration++;

            } while (currentGeneration < generations);

            return current;
        }
    }
}
