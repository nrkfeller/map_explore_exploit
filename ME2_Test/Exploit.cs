using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ME2_Test
{
    static class ExploitFunctions
    {
        public static double ExploitP(Individual parent, Individual child, double totalFitness)
        {
            double normalizedParentFitness = parent.Fitness / totalFitness;
            double normalizedChildFitness = child.Fitness / totalFitness;
            double p = 0.0D;
            if (normalizedChildFitness > normalizedParentFitness)
            {
                p = normalizedChildFitness - normalizedParentFitness;
            }
            return p;
        }
        public static double ExploitTP(Space searchSpace, Individual parent, Individual child, double totalFitness)
        {
            double transitionProbability = ExploitFunctions.ExploitP(parent, child, totalFitness);
            double ncbd = ME2Functions.NormalizedCityBlockDistance(searchSpace, parent, child);
            if (Math.Abs(ncbd - 0.0D) < Constants.TOLERANCE)
            {
                transitionProbability = 0.0D;
            }

            return transitionProbability;
        }
        public static IEnumerable<Individual> ExploitNeighbors(Space searchSpace, bool maximize, Individual groupMember, Func<Space, Individual, Func<Individual, bool, double>, bool, Action<Individual, double>, Individual> mutation, Func<Individual, bool, double> fitness, Action<Individual, double> applyFitness, int number)
        {
            for(int i = 0; i < number; i++)
            {
                Individual neighbor = mutation(searchSpace, groupMember, fitness, maximize, applyFitness);
                yield return neighbor;
            }
        }
        public static void ApplyExploitPOM(Space S, Individual IndividualToAdjust)
        {
            IndividualToAdjust.MutationProbability = 1.0 / S.Size;
        }

    }
    
    class Exploit<S, T, C>
    {
        public Func<S, bool, T, Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T>, Func<T, bool, C>, Action<T, C>, int, IEnumerable<T>> Neighbors { get; set; }
        public Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T> Mutate { get; set; }
        public Func<T, bool, C> Fitness { get; set; }
        public Func<IEnumerable<T>, C> TotalFitness { get; set; }
        public Action<T, C> ApplyFitness { get; set; }
        public Func<S, T, T, C, C> TransitionProbability { get; set; }
        public IEnumerable<T> Optimized { get; set; }
        private List<T> tabuList = new List<T>();

        public Exploit(S space, bool maximize, IEnumerable<T> parents, Func<S, bool, T, Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T>, Func<T, bool, C>, Action<T, C>, int, IEnumerable<T>> neighbors, 
                       Func<S, T, Func<T, bool, C>, bool, Action<T, C>, T> mutate, Func<T, bool, C> fitness, Action<T, C> applyFitness, Action<S, T> applyPOM, Func<S, T, T, C, C> transitionProbability,
                       Func<IEnumerable<T>, C> totalFitness, int generations)
        {
            this.Mutate = mutate;
            this.Neighbors = neighbors;
            this.Fitness = fitness;
            this.TotalFitness = totalFitness;
            this.ApplyFitness = applyFitness;
            this.TransitionProbability = transitionProbability;
            ConcurrentBag<T> oldSet = new ConcurrentBag<T>(parents);
            for(int i = 0; i < oldSet.Count(); i++)
            {
                applyPOM(space, oldSet.ElementAt(i));
            }
            ConcurrentBag<T> newSet = new ConcurrentBag<T>();
            Parallel.For(0, oldSet.Count(), current =>
                {
                    newSet.Add(this.Optimize(space, maximize, oldSet.Count(), oldSet.ElementAt(current), generations));
                }
            );
            Optimized = newSet;
        }
        private T Optimize(S space, bool maximize, int neighbors, T parent, int generations)
        {
            int currentGeneration = 0;
            List<C> transitionalProbabilities = new List<C>();
            T current = parent;

            do
            {
                IEnumerable<T> newNeighbors = this.Neighbors(space, maximize, current, this.Mutate, this.Fitness, this.ApplyFitness, neighbors);
                C newTotalFitness = this.TotalFitness(newNeighbors);
                foreach(T neighbor in newNeighbors)
                {
                    transitionalProbabilities.Add(this.TransitionProbability(space, current, neighbor, newTotalFitness));
                }
                int bestIndex = transitionalProbabilities.IndexOf(transitionalProbabilities.Max());
                if(newNeighbors.ElementAt(bestIndex) != null && !tabuList.Contains(newNeighbors.ElementAt(bestIndex)))
                {
                    tabuList.Add(current);
                    current = newNeighbors.ElementAt(bestIndex);
                }
                transitionalProbabilities.Clear();
                currentGeneration++;
            } while (currentGeneration < generations);

            return current;
        }
    }
}
