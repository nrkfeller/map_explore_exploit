using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MathNet.Numerics.Random;
using MathNet.Numerics.Distributions;

namespace ME2_Test
{
    static class ME2Functions
    {
        private static MersenneTwister _rng = new MersenneTwister(true);
        public static Individual RandomIndividual(Space SearchSpace)
        {
            Individual randomIndividual = new Individual();
            for (int i = 0; i < SearchSpace.Size; i++)
            {
                if (i >= 0 && i < SearchSpace.RealAxes)
                {
                    randomIndividual.Genotype.Add(ContinuousUniform.Sample(ME2Functions._rng, (double)((RealAxis)SearchSpace[i]).Min, (double)((RealAxis)SearchSpace[i]).Max));
                }
                else if (i >= SearchSpace.RealAxes && i < SearchSpace.DiscreteAxes)
                {
                    randomIndividual.Genotype.Add(DiscreteUniform.Sample(ME2Functions._rng, (int)((DiscreteAxis)SearchSpace[i]).Min, (int)((DiscreteAxis)SearchSpace[i]).Max));
                }
                else
                {
                    bool randomBool = Convert.ToBoolean(ME2Functions._rng.Next(0, 2));
                    randomIndividual.Genotype.Add(randomBool);
                }
            }
            randomIndividual.MutationStep = 1.0;
            randomIndividual.MutationProbability = 1.0;
            return randomIndividual;
        }
        public static double Ackley(Individual IndividualToTest, bool Maximize)
        {
            double s1 = 0.0, s2 = 0.0;
            int doublesInGenotype = 0;

            for (int i = 0; i < IndividualToTest.Size; i++)
            {
                if (IndividualToTest[i] is double) // Ignore all non-real values
                {
                    s1 = s1 + Math.Pow((double)IndividualToTest[i], 2.0);
                    s2 = s2 + Math.Cos(2.0 * Math.PI * (double)IndividualToTest[i]);
                    doublesInGenotype++;
                }
            }

            s1 /= doublesInGenotype;
            s1 = -0.2 * Math.Sqrt(s1);

            s2 /= doublesInGenotype;

            double result = (-20.0 * Math.Exp(s1)) - Math.Exp(s2) + 20.0 + Math.E;
            return (Maximize ? result : 1.0 / result);
        }
        public static double TotalFitness(IEnumerable<Individual> Group)
        {
            return Group.Sum(current => current.Fitness);
        }
        public static IEnumerable<Individual> RouletteSelection(IEnumerable<Individual> Group, int numberOfSurvivors)
        {
            if (numberOfSurvivors < 1)
            {
                numberOfSurvivors = 1;
            }
            else if (numberOfSurvivors > Group.Count())
            {
                numberOfSurvivors = Group.Count();
            }
            double r = 0.0;
            int i = 0;
            double totalFitness = ME2Functions.TotalFitness(Group);
            Individual[] temp = new Individual[numberOfSurvivors];
            for (int selected = 0; selected < numberOfSurvivors; selected++)
            {
                r = ME2Functions._rng.NextDouble();
                r = r * totalFitness;
                i = 0;

                while (r > Constants.TOLERANCE)
                {
                    r -= Group.ElementAt(i).Fitness;
                    i++;
                }
                temp[selected] = Group.ElementAt(i - 1);
            }
            return temp;
        }
        public static void ApplyFitness(Individual ToApply, double Fitness)
        {
            ToApply.Fitness = Fitness;
        }
        public static void ApplyProbability(Individual ToApply, double MutationProbability)
        {
            ToApply.MutationProbability = MutationProbability;
        }
        public static Individual NormalMutate(Space SearchSpace, Individual IndividualToMutate, Func<Individual, bool, double> Fitness, bool maximize, Action<Individual, double> ApplyFitness)
        {
            // First mutate sigma
            double tau = 1.0 / (2.0 * Math.Sqrt(IndividualToMutate.Size)); // Learning rate inversely proportional to the sqrt of genotype size
            double NT = Normal.Sample(ME2Functions._rng, 0, tau);

            // The value below CANNOT BE USED as sigma
            // Sigma is this value * the allele value
            IndividualToMutate.MutationStep = IndividualToMutate.MutationStep * Math.Exp(NT);

            // Now create a mutant genotype using the original genotype of the Individual
            var resultingGenotype = new List<object>();
            double probability = 0.0;
            for (int i = 0; i < IndividualToMutate.Size; i++)
            {
                // Check whether to mutate this allele
                probability = ContinuousUniform.Sample(ME2Functions._rng, 0.0, 1.0);
                if (probability < IndividualToMutate.MutationProbability)
                {
                    // Allele will be mutated
                    if (IndividualToMutate[i] is bool)
                    {
                        resultingGenotype.Add(!(bool)IndividualToMutate[i]);
                    }
                    else if (IndividualToMutate[i] is int)
                    {
                        double newAllele = (double)IndividualToMutate[i];
                        double NS = Normal.Sample(ME2Functions._rng, 0, Math.Abs(newAllele * IndividualToMutate.MutationStep));
                        newAllele += NS;
                        int minValue = ((DiscreteAxis)SearchSpace[i]).Min;
                        int maxValue = ((DiscreteAxis)SearchSpace[i]).Max;
                        if(newAllele < minValue)
                        {
                            newAllele = minValue;
                        }
                        else if(newAllele > maxValue)
                        {
                            newAllele = maxValue;
                        }
                        resultingGenotype.Add((int)newAllele);
                    }
                    else
                    {
                        double newAllele = (double)IndividualToMutate[i];
                        double NS = Normal.Sample(ME2Functions._rng, 0, Math.Abs(newAllele * IndividualToMutate.MutationStep));
                        newAllele += NS;
                        double minValue = ((RealAxis)SearchSpace[i]).Min;
                        double maxValue = ((RealAxis)SearchSpace[i]).Max;
                        if(newAllele < minValue)
                        {
                            newAllele = minValue;
                        }
                        else if(newAllele > maxValue)
                        {
                            newAllele = maxValue;
                        }
                        resultingGenotype.Add(newAllele);
                    }
                }
                else
                {
                    // Allele will not be mutated
                    resultingGenotype.Add(IndividualToMutate[i]);
                }
            }

            // Return an Individual with the mutant genotype
            Individual mutant = new Individual();
            mutant.Genotype = resultingGenotype;
            mutant.MutationProbability = IndividualToMutate.MutationProbability;
            mutant.MutationStep = IndividualToMutate.MutationStep;
            double newFitness = Fitness(mutant, maximize);
            ApplyFitness(mutant, newFitness);
            return mutant;
        }
        public static double NormalizedCityBlockDistance(Space SearchSpace, Individual Source, Individual Destination)
        {
            double ncbd = 0.0;
            for (int i = 0; i < Source.Size; i++)
            {
                if (Source[i] is bool)
                {
                    ncbd += 1.0;
                }
                else if (Source[i] is int)
                {
                    ncbd += (double)(Math.Abs((int)Source[i] - (int)Destination[i]) / ((DiscreteAxis)SearchSpace[i]).RangeProper);
                }
                else if (Source[i] is double)
                {
                    ncbd += (Math.Abs((double)Source[i] - (double)Destination[i]) / ((RealAxis)SearchSpace[i]).RangeProper);
                }
            }
            return ncbd;
        }
        
    }
}
