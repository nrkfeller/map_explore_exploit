#Map Explore Exploit | ME2
Metaheuristic optimization deals with optimization problems using metaheuristic algorithms. Optimization is essentially everywhere, from engineering design to economics and from holiday planning to Internet routing. As money, resources and time are always limited, the optimal utility of these available resources is crucially important.

This algorithm aims at combining the advantages of Tabu Search - Simulated Annealing - Differential Evolution.

#Description 
##MAP
First step, optimization process to carry out stratified uniformy-random sampling of the solution space. Uniform sampling along one direction, then again along the next dimension and so on, until we have a sample on all dimension of the candidate solution.

Second step, decide on approximate fitness calculation of the first set of samples. what part of the solution space deserves what quantity of samples.

Third Step, every time we generate a new sample, we find the closest pole and decrement the maximum amount of neighborhood samples (by one). Distance should be measured using normalized city block formula.

##Explore & Exploit
Mixing of tabu search and simulated annealing. Keep a list of forbidden position, list has LIFO structure, with length based on sample size. Simulated annealing has cooling factor based on the range of the sample space. This is a function of the input values to allow plug and play.

#Steps
##Map
0. Given a sample 
    s with fitness f(s)
1. Generate an incomplete set of neighbors
    S'={s0',.. si' ..,sm'}
    This is done by mutation, mutation size is how far the randomness can range, basically a normal distribution type standard deviation.
2. Compute the fitness value of S'
3. Compute the transition probability. Probability that a point will transision to another point. Based on distance and fitness. Use tabu list and simulated cooling
    TP = P(f(s), f(si'), D) - RND(1)
4. Let the new point be the complement with the highest TP - transition probability.
    s = s' (where max(TP))
5. Add old S to the top of tabu queue
6. If and only if the new points fitness is greater than the old points fitness. assign
    IFF f(new s) > f(best_s) let best_s = new s
7. Repeat 1-6. Until a set number of iterations have passed without updating best_s
##Exploit
8. After exiting set 7. take best_s as s
9. Generate complete, dense set of neighbors by mutation
    S'={s0',.. si' ..,sm'}
10. Compute the fitness value of all members of S'
11. Compute the probability distribution for S'
    Differential evolution. Only move is the child generated is fitter than the parent.
12. Let the point be the best new point. s' with greatest fit value
13. If if the s is new, place old s on the tabu list
14. Repeat 8-13. Until a set number of iterations have passed without updating best_s

Get best fit of all 'explorers' and return that value
